<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Romantic AR</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif; }

    /* iPhone SafariのURLバー伸縮対策（innerHeightで追従） */
    :root { --vh: 100vh; }
    @supports (height: 100dvh) { :root { --vh: 100dvh; } }
    html, body { width: 100%; height: 100%; }

    a-scene {
      position: fixed !important;
      left: 0; top: 0;
      width: 100vw !important;
      height: var(--vh) !important;
      z-index: 1;
    }
    .a-canvas, canvas.a-canvas{
      width: 100vw !important;
      height: var(--vh) !important;
      display: block !important;
    }

    /* 演出Canvas（カメラの上） */
    #fxCanvas{
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: var(--vh);
      z-index: 3;
      pointer-events: none;
      display: none;
    }

    /* ふわっと周辺を落とす */
    #vignette{
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: var(--vh);
      z-index: 4;
      pointer-events: none;
      display:none;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.35) 100%);
      mix-blend-mode: multiply;
    }

    /* START画面 */
    #ui {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.65);
      z-index: 10;
    }
    #panel{
      width: min(560px, 90vw);
      color: #fff;
      background: rgba(20,20,24,0.78);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      padding: 16px 16px 12px;
    }
    #panel h1{ font-size: 18px; margin: 0 0 8px; font-weight: 900; }
    #panel p{ font-size: 14px; margin: 6px 0; line-height: 1.45; color: rgba(255,255,255,0.9); }
    #startBtn{
      margin-top: 10px;
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 0;
      background: rgba(255,255,255,0.92);
      color: #111;
      font-size: 16px;
      font-weight: 900;
    }

    #hint{
      position: fixed; left: 0; right: 0;
      bottom: env(safe-area-inset-bottom);
      padding: 10px 12px;
      text-align: center;
      font-size: 13px;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 2px 10px rgba(0,0,0,0.75);
      pointer-events: none;
      z-index: 11;
      display: none;
      white-space: pre-line;
    }
  </style>
</head>

<body>
  <div id="ui">
    <div id="panel">
      <h1>AR</h1>
      <p>1) START → カメラ許可</p>
      <p>2) マーカー画像を映す</p>
      <button id="startBtn">START</button>
    </div>
  </div>

  <div id="hint">STARTを押してください</div>
  <canvas id="fxCanvas"></canvas>
  <div id="vignette"></div>

  <!-- START前に追跡開始しない -->
  <a-scene
    id="scene"
    mindar-image="imageTargetSrc: ./targets.mind; autoStart: false; maxTrack: 1; warmupTolerance: 0; missTolerance: 30; filterMinCF: 0.00001; filterBeta: 0.0001;"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false"
    renderer="colorManagement: true"
  >
    <a-camera position="0 0 0" look-controls="enabled:false"></a-camera>
    <!-- targets.mind が1枚だけなら targetIndex:0 -->
    <a-entity id="target0" mindar-image-target="targetIndex: 0"></a-entity>
  </a-scene>

  <script>
    // =====================
    // 調整ポイント（必要ならここだけ）
    // =====================
    const STABLE_MS = 1100; // 認識確定まで（早すぎるなら 1200〜1400）

    // 暖色ボケの色
    const ILLUMI_PALETTE = [
      [255, 244, 214], // warm white
      [255, 214, 140], // amber
      [255, 190, 110], // gold
      [255, 210, 235], // blush pink
      [210, 230, 255], // cool white（少量）
    ];

    // 量/サイズ/速度
    const FX = {
      // Warm Bokeh（twinkle付き）
      illumiNear:  { count: 24, r:[18,32], vy:[6,12],  vx:[-18,-8],  a:[0.10,0.18] },
      illumiMid:   { count: 40, r:[10,18], vy:[10,18], vx:[-14,-6],  a:[0.10,0.22] },
      illumiFar:   { count: 66, r:[4,10],  vy:[14,24], vx:[-10,-4],  a:[0.08,0.18] },

      // Snow：右→左に流れる（横向きイメージ固定）
      snowNear: { count: 120, r:[1.8,3.2],  vx:[-220,-140], vy:[25,55],  a:[0.10,0.22], drift:14, layer:"near" },
      snowMid:  { count: 200, r:[1.2,2.2],  vx:[-170,-100], vy:[35,70],  a:[0.08,0.18], drift:18, layer:"mid"  },
      snowFar:  { count: 280, r:[0.8,1.6],  vx:[-130,-70],  vy:[45,90],  a:[0.06,0.14], drift:22, layer:"far"  },
    };

    // 雪の層別グロー（近景強め／遠景弱め）
    const SNOW_GLOW = {
      near: { Rmul: 4.2, glowMul: 0.70, coreMul: 0.95 },
      mid:  { Rmul: 3.2, glowMul: 0.50, coreMul: 0.85 },
      far:  { Rmul: 2.4, glowMul: 0.32, coreMul: 0.78 },
    };

    // =====================
    // iPhoneの高さ対策
    // =====================
    function setVh() { document.documentElement.style.setProperty("--vh", window.innerHeight + "px"); }
    setVh();
    window.addEventListener("resize", setVh, { passive: true });
    window.addEventListener("orientationchange", setVh, { passive: true });

    // =====================
    // UI/エラー表示
    // =====================
    const ui = document.getElementById("ui");
    const hint = document.getElementById("hint");
    const sceneEl = document.getElementById("scene");
    const target0 = document.getElementById("target0");
    const fxCanvas = document.getElementById("fxCanvas");
    const vignette = document.getElementById("vignette");
    const startBtn = document.getElementById("startBtn");
    const ctx = fxCanvas.getContext("2d");

    function logMsg(msg){
      hint.style.display = "block";
      hint.textContent = msg;
    }
    window.addEventListener("error", (e)=>logMsg("エラー: " + (e.message || "不明")));
    window.addEventListener("unhandledrejection", (e)=>{
      const m = (e.reason && e.reason.message) ? e.reason.message : String(e.reason);
      logMsg("起動失敗: " + m);
    });

    function getMindarSystem(){
      return sceneEl.systems && sceneEl.systems["mindar-image-system"];
    }

    // =====================
    // 認識→確定→固定
    // =====================
    let started = false;
    let locked = false;
    let visible = false;
    let stableTimer = null;

    function clearStable(){
      if (stableTimer){ clearTimeout(stableTimer); stableTimer=null; }
    }

    function scheduleLock(){
      if (!started || locked) return;
      if (stableTimer) return;

      stableTimer = setTimeout(()=>{
        stableTimer = null;
        if (!started || locked) return;

        if (visible){
          locked = true;
          fxStart();
          logMsg("OK（リロードするまで固定表示）");

          // 追跡を止める（環境によりpause無しの場合がある）
          try{
            const sys = getMindarSystem();
            if (sys && typeof sys.pause === "function") sys.pause();
          }catch(_){}
        }
      }, STABLE_MS);
    }

    // =====================
    // FX（Warm Bokeh + Snow + Twinkle / 雪は右→左固定）
    // =====================
    let rafId = null;
    let fxRunning = false;
    let particles = [];
    let lastT = 0;

    function rand(a,b){ return a + Math.random()*(b-a); }
    function pickCol(){
      return ILLUMI_PALETTE[Math.floor(Math.random()*ILLUMI_PALETTE.length)];
    }

    function resizeFx(){
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      fxCanvas.width  = Math.floor(window.innerWidth * dpr);
      fxCanvas.height = Math.floor(window.innerHeight * dpr);
      fxCanvas.style.width = window.innerWidth + "px";
      fxCanvas.style.height = window.innerHeight + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function initFx(){
      particles = [];
      const w = window.innerWidth, h = window.innerHeight;

      function mkIllumi(G){
        particles.push({
          kind: "illumi",
          x: Math.random()*w,
          y: Math.random()*h,
          vx: rand(G.vx[0], G.vx[1]),
          vy: rand(G.vy[0], G.vy[1]),
          r:  rand(G.r[0],  G.r[1]),
          a:  rand(G.a[0],  G.a[1]),
          col: pickCol(),
          phase: Math.random()*Math.PI*2,
          tw: rand(0.7, 1.6),      // twinkle速度
          twAmp: rand(0.18, 0.38), // twinkle強さ
          wobble: rand(4, 10)      // 揺れ（控えめ）
        });
      }

      function mkSnow(G){
        // 右側から入ってくる印象を強めるため、初期xは少し右側にも散らす
        const x0 = rand(-0.1*w, 1.2*w);
        const y0 = rand(-0.1*h, 1.1*h);

        particles.push({
          kind: "snow",
          layer: G.layer,
          x: x0,
          y: y0,
          vx: rand(G.vx[0], G.vx[1]), // ★負（右→左）
          vy: rand(G.vy[0], G.vy[1]),
          r:  rand(G.r[0],  G.r[1]),
          a:  rand(G.a[0],  G.a[1]),
          drift: G.drift
        });
      }

      // bokeh
      for (let i=0;i<FX.illumiNear.count;i++) mkIllumi(FX.illumiNear);
      for (let i=0;i<FX.illumiMid.count;i++)  mkIllumi(FX.illumiMid);
      for (let i=0;i<FX.illumiFar.count;i++)  mkIllumi(FX.illumiFar);

      // snow（層別）
      for (let i=0;i<FX.snowNear.count;i++) mkSnow(FX.snowNear);
      for (let i=0;i<FX.snowMid.count;i++)  mkSnow(FX.snowMid);
      for (let i=0;i<FX.snowFar.count;i++)  mkSnow(FX.snowFar);
    }

    function fxStart(){
      if (fxRunning) return;
      fxRunning = true;
      fxCanvas.style.display = "block";
      vignette.style.display = "block";
      resizeFx();
      initFx();
      lastT = performance.now();
      rafId = requestAnimationFrame(tickFx);
    }

    function fxStop(){
      fxRunning = false;
      fxCanvas.style.display = "none";
      vignette.style.display = "none";
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    }

    function respawnSnow(p, w, h){
      // 右側から入る：xを画面右外へ、yは上〜中くらいに戻す
      p.x = w + rand(20, 120);
      p.y = rand(-40, h * 0.75);
      // 風も少し揺らす
      p.vx += (Math.random()-0.5) * p.drift;
      p.vx = Math.min(-40, p.vx); // 必ず左方向
    }

    function tickFx(t){
      if (!fxRunning) return;
      const dt = Math.min(0.05, (t-lastT)/1000);
      lastT = t;

      const w = window.innerWidth, h = window.innerHeight;
      ctx.clearRect(0,0,w,h);

      // ---- Warm Bokeh（twinkle）----
      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      for (const p of particles){
        if (p.kind !== "illumi") continue;

        p.phase += dt*p.tw;
        p.x += p.vx*dt + Math.sin(p.phase)*p.wobble*dt;
        p.y += p.vy*dt * 0.5;

        // ループ
        if (p.x < -160) p.x = w + 160;
        if (p.x > w + 160) p.x = -160;
        if (p.y < -160) p.y = h + 160;
        if (p.y > h + 160) p.y = -160;

        const tw = 1 + Math.sin(p.phase*1.25)*p.twAmp;
        const a = Math.max(0, Math.min(1, p.a*tw));
        const [r,g,b] = p.col;

        const R1 = p.r * 2.4; // 外側
        const g1 = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,R1);
        g1.addColorStop(0, `rgba(${r},${g},${b},${a*0.24})`);
        g1.addColorStop(1, `rgba(${r},${g},${b},0)`);
        ctx.fillStyle = g1;
        ctx.beginPath(); ctx.arc(p.x,p.y,R1,0,Math.PI*2); ctx.fill();

        const R2 = p.r; // コア
        const g2 = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,R2);
        g2.addColorStop(0, `rgba(${r},${g},${b},${a*0.90})`);
        g2.addColorStop(1, `rgba(${r},${g},${b},0)`);
        ctx.fillStyle = g2;
        ctx.beginPath(); ctx.arc(p.x,p.y,R2,0,Math.PI*2); ctx.fill();
      }

      ctx.restore();

      // ---- Snow（右→左固定 + 層別グロー）----
      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      for (const p of particles){
        if (p.kind !== "snow") continue;

        // 右→左 + 少し下（横向きイメージ固定）
        p.x += p.vx*dt;
        p.y += p.vy*dt;

        // 微風（速度のブレ）
        p.vx += (Math.random()-0.5) * 18 * dt;
        // 左方向を維持（0に近づき過ぎないように）
        p.vx = Math.min(-40, p.vx);

        // 画面外に出たら右から復帰
        if (p.x < -60 || p.y > h + 60) {
          respawnSnow(p, w, h);
        }

        const L = SNOW_GLOW[p.layer || "mid"];

        const Rg = p.r * L.Rmul;
        const ag = Math.min(1, p.a * L.glowMul);

        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, Rg);
        g.addColorStop(0, `rgba(255,255,255,${ag})`);
        g.addColorStop(1, `rgba(255,255,255,0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(p.x, p.y, Rg, 0, Math.PI*2); ctx.fill();

        const ac = Math.min(1, p.a * L.coreMul);
        ctx.fillStyle = `rgba(255,255,255,${ac})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
      }

      ctx.restore();

      rafId = requestAnimationFrame(tickFx);
    }

    window.addEventListener("resize", ()=>{
      resizeFx();
      if (fxRunning) initFx();
    }, {passive:true});

    // =====================
    // MindAR イベント
    // =====================
    target0.addEventListener("targetFound", ()=>{
      if (!started || locked) return;
      visible = true;
      scheduleLock();
    });

    target0.addEventListener("targetLost", ()=>{
      // locked後は消えない（リロードまで固定）
      if (!started || locked) return;
      visible = false;
      clearStable();
      fxStop();
      logMsg("カードを映してください");
    });

    // =====================
    // START
    // =====================
    startBtn.addEventListener("click", async ()=>{
      ui.style.display = "none";
      logMsg("初期化中…");

      try{
        if (!sceneEl.hasLoaded){
          await new Promise(res => sceneEl.addEventListener("loaded", res, {once:true}));
        }
        const sys = getMindarSystem();
        if (!sys) throw new Error("mindar-image-system が見つかりません");

        await sys.start();
        started = true;

        // 画面サイズ再計算（iOSで表示が崩れたときの保険）
        window.dispatchEvent(new Event("resize"));

        logMsg("カードを映してください");
      }catch(err){
        logMsg("起動失敗: " + (err?.message || String(err)));
        ui.style.display = "flex";
      }
    });

    // 初期表示
    logMsg("STARTを押してください");
    resizeFx();
  </script>
</body>
</html>
